package parser

import (
	"fmt"
	"vabna/ast"
	"vabna/lexer"
	"vabna/token"
)

type Parser struct{
    lx *lexer.Lexer
    curTok token.Token
    peekTok token.Token
}

func NewParser(l *lexer.Lexer) Parser{
    
    p:= Parser{lx: l}
    p.nextToken()
    p.nextToken()

    return p

}

func (p *Parser) nextToken(){
    p.curTok = p.peekTok
    p.peekTok = p.lx.NextToken()
}

func (p *Parser) ParseProg() ast.Program{
    prog := ast.Program{}
    prog.Stmts = []ast.Stmt{}
    
    for p.curTok.Type != token.EOF{
        //fmt.Println(p.curTok)
        stmt := p.parseStmt()
        
        if stmt != nil{
            prog.Stmts = append(prog.Stmts, stmt)
        }

        p.nextToken()
    }

    return prog
}

func (p *Parser) parseStmt() ast.Stmt{
    switch p.curTok.Type{
        case token.LET:
            return p.parseLetStmt()

        default:
            return nil

    }
}

func (p *Parser) parseLetStmt() *ast.LetStmt{
    
    stmt := ast.LetStmt{Token: p.curTok}
    stmt.Name  = ast.Identifier{Token: p.curTok , Value: p.curTok.Literal}
    
    if !p.peek(token.EQ){
        return nil
    }

    for !p.isCurToken(token.SEMICOLON){
        p.nextToken()
    }

    return &stmt

}

func (p *Parser) isCurToken(t token.TokenType) bool{
// check if current token type is `t`
    return p.curTok.Type == t
}

func (p *Parser) isPeekToken(t token.TokenType) bool{
// check if next token type is `t`
    return p.peekTok.Type == t
}

func (p *Parser) peek(t token.TokenType) bool{
// checks if next token type is `t`
// and if yes, then advance to next token
    if p.isPeekToken(t){
        p.nextToken()
        return true
    }

    return false
}
